---
title: The Hardest Thing in Programming is People
date: 02-28-2026
image: people-complexity.png
description: Programming is automating thought, and thought is inherently human.
---

I once watched a team spend three weeks building a feature that perfectly solved the wrong problem. The code was clean, the tests passed, and the implementation was elegant. But somewhere between the customer's complaint and the developer's keyboard, the actual need got lost in translation.

The technical work was straightforward. The human communication was where everything broke down.

This pattern repeats everywhere in software. Technical concepts — even the tricky ones like pointers or async programming — have clear rules. You can sit with them long enough and figure them out. The difficulty isn't in the code itself. The difficulty is in the people.

## Software as Automated Thought

Understanding why people make software hard requires understanding what software actually is. I think of it as the latest step in the evolution of human communication.

First came physical gestures and vocal sounds. Then speech — the ability to take a thought process in your head and replay it in someone else's mind in real time. Then writing evolved, which let you record those thought processes and send them across distance and time.

Software is the next layer. When you write code, you're taking a process that someone does manually — a series of decisions and actions — and automating it so it can run at a speed and scale humans can't match. You're not just writing instructions for a computer. You're capturing human thought processes and making them executable.

This is why a customer success manager reviewing support tickets isn't fundamentally different from a script that categorizes them. Both are following a decision tree. The software version just runs faster and doesn't need sleep.

The implication: every software project is trying to capture and automate someone's thinking.

## Where the Complexity Lives

If software is automated thought, the hard part is accurately capturing the right thoughts from the right people. This requires solving several human problems that have no algorithmic solution.

You're working from incomplete information. You don't sit with customers while they use your app. You can't read your coworker's actual motivations. A product manager interprets what a customer says, a designer interprets that interpretation, and then you interpret the designer's mockups. At each step, information degrades.

The founder has a vision. Does it match what customers actually need? You can't know until you build it, ship it, and watch what happens. By then you've invested weeks or months.

Developers get siloed. Each team develops its own patterns and assumptions. Code is documentation we're trying to write together, but when there's no shared understanding of structure and purpose, every new feature becomes harder to add. The technical debt isn't in the code — it's in the misaligned mental models.

Consider the information chain: a customer has a problem, tells support, who files a ticket, which a product manager reviews and prioritizes, which a designer mocks up, which an engineer builds. Every person in that chain has their own goals, pressures, and incentives. The support rep wants to close tickets quickly. The product manager wants to hit roadmap goals. The designer wants clean interfaces. The engineer wants maintainable code.

These goals aren't necessarily aligned. When they conflict, the complexity multiplies. Not because the code is hard, but because the people haven't agreed on what success looks like.

## What This Means for Developers

I've watched developers master algorithms, system design, and architectural patterns, then struggle to understand why their carefully built features don't get used. The gap is usually communication.

When you write code, you're translating someone else's thought process into executable instructions. That translation requires understanding what they actually meant, not just what they said. It requires asking clarifying questions. It requires checking your assumptions.

This is why I think programming resembles writing more than it resembles mathematics. Math has provably correct answers. Writing — and programming — requires making yourself understood by another person. You can write syntactically correct code that solves the wrong problem, just like you can write grammatically correct sentences that miss the point.

The developers who have the most impact aren't necessarily the ones who write the cleverest code. They're the ones who can listen to a customer, ask the right questions, translate that into a technical approach, and then communicate that approach to their team. The technical execution matters, but it comes after the human understanding.

## Conclusion

Building software means capturing and automating human thought processes. Those processes live in people's heads, which means you can't extract them with better tools or smarter algorithms. You extract them through conversation, observation, and iteration.

The hardest thing about software is people because software is fundamentally about people. The code is just the artifact. The real work is understanding what to build, why it matters, and how it fits into someone's actual workflow.

Technical skills create possibilities. Communication skills determine whether those possibilities become something useful.
